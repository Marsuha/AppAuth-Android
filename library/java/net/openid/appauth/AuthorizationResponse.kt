/*
 * Copyright 2015 The AppAuth for Android Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.openid.appauth

import android.content.Intent
import android.net.Uri
import androidx.annotation.VisibleForTesting
import org.json.JSONException
import org.json.JSONObject
import java.util.concurrent.TimeUnit

/**
 * A response to an authorization request.
 *
 * @see AuthorizationRequest
 *
 * @see "The OAuth 2.0 Authorization Framework
 */
@Suppress("unused")
class AuthorizationResponse private constructor(
    /**
     * The authorization request associated with this response.
     */
    @JvmField val request: AuthorizationRequest,
    /**
     * The returned state parameter, which must match the value specified in the request.
     * AppAuth for Android ensures that this is the case.
     */
    override val state: String?,
    /**
     * The type of the retrieved token. Typically this is "Bearer" when present. Otherwise,
     * another token_type value that the Client has negotiated with the Authorization Server.
     *
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.2.2.5">
     *     OpenID Connect Core 1.0, Section 3.2.2.5</a>
     */
    @JvmField val tokenType: String?,
    /**
     * The authorization code generated by the authorization server.
     * Set when the response_type requested includes 'code'.
     */
    @JvmField val authorizationCode: String?,
    /**
     * The access token retrieved as part of the authorization flow.
     * This is available when the [response_type][AuthorizationRequest.responseType]
     * of the request included 'token'.
     *
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.2.2.5">
     *     OpenID Connect Core 1.0, Section 3.2.2.5</a>
     */
    @JvmField val accessToken: String?,
    /**
     * The approximate expiration time of the access token, as milliseconds from the UNIX epoch.
     * Set when the requested [response_type][AuthorizationRequest.responseType]
     * included 'token'.
     *
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.2.2.5">
     *     OpenID Connect Core 1.0, Section 3.2.2.5</a>
     */
    @JvmField val accessTokenExpirationTime: Long?,
    /**
     * The id token retrieved as part of the authorization flow.
     * This is available when the [response_type][AuthorizationRequest.responseType]
     * of the request included 'id_token'.
     *
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.2">
     *     OpenID Connect Core 1.0, Section 2</a>
     *
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.2.2.5">
     *     OpenID Connect Core 1.0, Section 3.2.2.5</a>
     */
    @JvmField val idToken: String?,
    /**
     * The scope of the returned access token. If this is not specified, the scope is assumed
     * to be the same as what was originally requested.
     */
    @JvmField val scope: String?,
    /**
     * The additional, non-standard parameters in the response.
     */
    val additionalParameters: Map<String, String>
) : AuthorizationManagementResponse {
    /**
     * Creates instances of [AuthorizationResponse].
     */
    class Builder(request: AuthorizationRequest) {
        private val mRequest: AuthorizationRequest = request

        private var mState: String? = null

        private var mTokenType: String? = null

        private var mAuthorizationCode: String? = null

        private var mAccessToken: String? = null

        private var mAccessTokenExpirationTime: Long? = null

        private var mIdToken: String? = null

        private var mScope: String? = null

        private var mAdditionalParameters: Map<String, String> = emptyMap()

        /**
         * Extracts authorization response parameters from the query portion of a redirect URI.
         */
        fun fromUri(uri: Uri) = fromUri(uri, SystemClock)

        @Suppress("SameParameterValue")
        @VisibleForTesting
        fun fromUri(uri: Uri, clock: Clock): Builder {
            setState(uri.getQueryParameter(KEY_STATE))
            setTokenType(uri.getQueryParameter(KEY_TOKEN_TYPE))
            setAuthorizationCode(uri.getQueryParameter(KEY_AUTHORIZATION_CODE))
            setAccessToken(uri.getQueryParameter(KEY_ACCESS_TOKEN))
            setAccessTokenExpiresIn(uri.getQueryParameter(KEY_EXPIRES_IN)?.toLong(), clock)
            setIdToken(uri.getQueryParameter(KEY_ID_TOKEN))
            setScope(uri.getQueryParameter(KEY_SCOPE))
            setAdditionalParameters(uri.extractAdditionalParams(BUILT_IN_PARAMS))
            return this
        }

        /**
         * Specifies the OAuth 2 state.
         */
        fun setState(state: String?): Builder {
            state?.let { require(it.isNotEmpty()) { "state must not be empty" } }
            mState = state
            return this
        }

        /**
         * Specifies the OAuth 2 token type.
         */
        fun setTokenType(tokenType: String?): Builder {
            tokenType?.let { require(it.isNotEmpty()) { "tokenType must not be empty" } }
            mTokenType = tokenType
            return this
        }

        /**
         * Specifies the OAuth 2 authorization code.
         */
        fun setAuthorizationCode(authorizationCode: String?): Builder {
            authorizationCode?.let { require(it.isNotEmpty()) { "authorizationCode must not empty" } }
            mAuthorizationCode = authorizationCode
            return this
        }

        /**
         * Specifies the OAuth 2 access token.
         */
        fun setAccessToken(accessToken: String?): Builder {
            accessToken?.let { require(it.isNotEmpty()) { "accessToken must not be empty" } }
            mAccessToken = accessToken
            return this
        }

        /**
         * Specifies the expiration period of the OAuth 2 access token.
         */
        fun setAccessTokenExpiresIn(expiresIn: Long?) =
            setAccessTokenExpiresIn(expiresIn, SystemClock)

        /**
         * Specifies the relative expiration time of the access token, in seconds, using the
         * provided clock as the source of the current time.
         */
        @VisibleForTesting
        fun setAccessTokenExpiresIn(expiresIn: Long?, clock: Clock): Builder {
            mAccessTokenExpirationTime = expiresIn?.let {
                (clock.currentTimeMillis + TimeUnit.SECONDS.toMillis(it))
            }

            return this
        }

        /**
         * Specifies the expiration time of the OAuth 2 access token.
         */
        fun setAccessTokenExpirationTime(expirationTime: Long?): Builder {
            mAccessTokenExpirationTime = expirationTime
            return this
        }

        /**
         * Specifies the OAuth 2 Id token.
         */
        fun setIdToken(idToken: String?): Builder {
            idToken?.let { require(it.isNotEmpty()) { "idToken must not be empty" } }
            mIdToken = idToken
            return this
        }

        /**
         * Specifies the encoded scope string, which is a space-delimited set of
         * case-sensitive scope identifiers. Replaces any previously specified scope.
         *
         * @see "The OAuth 2.0 Authorization Framework
         */
        fun setScope(scope: String?): Builder {
            if (scope.isNullOrEmpty()) {
                mScope = null
            } else {
                setScopes(*scope.split(" +").dropLastWhile { it.isEmpty() }.toTypedArray())
            }

            return this
        }

        /**
         * Specifies the set of case-sensitive scopes. Replaces any previously specified set of
         * scopes. Individual scope strings cannot be null or empty.
         *
         * @see "The OAuth 2.0 Authorization Framework
         */
        fun setScopes(vararg scopes: String): Builder {
            setScopes(listOf(*scopes))
            return this
        }

        /**
         * Specifies the set of case-sensitive scopes. Replaces any previously specified set of
         * scopes. Individual scope strings cannot be null or empty.
         *
         * @see "The OAuth 2.0 Authorization Framework
         */
        fun setScopes(scopes: Iterable<String>): Builder {
            mScope = AsciiStringListUtil.iterableToString(scopes)
            return this
        }

        /**
         * Specifies the additional set of parameters received as part of the response.
         */
        fun setAdditionalParameters(additionalParameters: Map<String, String>?): Builder {
            mAdditionalParameters = additionalParameters.checkAdditionalParams(BUILT_IN_PARAMS)
            return this
        }

        /**
         * Builds the Authorization object.
         */
        fun build(): AuthorizationResponse {
            return AuthorizationResponse(
                mRequest,
                mState,
                mTokenType,
                mAuthorizationCode,
                mAccessToken,
                mAccessTokenExpirationTime,
                mIdToken,
                mScope,
                mAdditionalParameters
            )
        }
    }

    /**
     * Determines whether the returned access token has expired.
     */
    val hasAccessTokenExpired: Boolean
        get() = hasAccessTokenExpired(SystemClock)

    @VisibleForTesting
    @Suppress("SameParameterValue")
    fun hasAccessTokenExpired(clock: Clock) =
        accessTokenExpirationTime != null && clock.currentTimeMillis > accessTokenExpirationTime

    val scopeSet: Set<String>?
        /**
         * Derives the set of scopes from the consolidated, space-delimited scopes in the
         * [.scope] field. If no scopes were specified on this response, the method will
         * return `null`.
         */
        get() = scope?.let { AsciiStringListUtil.stringToSet(it) }

    /**
     * Creates a follow-up request to exchange a received authorization code for tokens, including
     * the provided additional parameters.
     */
    /**
     * Creates a follow-up request to exchange a received authorization code for tokens.
     */
    @JvmOverloads
    fun createTokenExchangeRequest(
        additionalExchangeParameters: Map<String, String> = emptyMap()
    ): TokenRequest {
        checkNotNull(authorizationCode) { "authorizationCode not available for exchange request" }
        return TokenRequest.Builder(request.configuration, request.clientId)
            .setGrantType(GrantTypeValues.AUTHORIZATION_CODE)
            .setRedirectUri(request.redirectUri)
            .setCodeVerifier(request.codeVerifier)
            .setAuthorizationCode(authorizationCode)
            .setAdditionalParameters(additionalExchangeParameters)
            .setNonce(request.nonce)
            .build()
    }

    /**
     * Produces a JSON representation of the authorization response for persistent storage or local
     * transmission (e.g. between activities).
     */
    override fun jsonSerialize() = JSONObject().apply {
        put(KEY_REQUEST, request.jsonSerialize())
        state?.let { put(KEY_STATE, it) }
        tokenType?.let { put(KEY_TOKEN_TYPE, it) }
        authorizationCode?.let { put(KEY_AUTHORIZATION_CODE, it) }
        accessToken?.let { put(KEY_ACCESS_TOKEN, it) }
        accessTokenExpirationTime?.let { put(KEY_EXPIRES_AT, it) }
        idToken?.let { put(KEY_ID_TOKEN, it) }
        scope?.let { put(KEY_SCOPE, it) }
        put(KEY_ADDITIONAL_PARAMETERS, additionalParameters.toJsonObject())
    }

    /**
     * Produces an intent containing this authorization response. This is used to deliver the
     * authorization response to the registered handler after a call to
     * [AuthorizationService.performAuthorizationRequest].
     */
    override fun toIntent() = Intent().apply {
        putExtra(EXTRA_RESPONSE, jsonSerializeString())
    }

    companion object {
        /**
         * The extra string used to store an [AuthorizationResponse] in an intent by
         * [.toIntent].
         */
        const val EXTRA_RESPONSE: String = "net.openid.appauth.AuthorizationResponse"

        /**
         * Indicates that a provided access token is a bearer token.
         * @see "The OAuth 2.0 Authorization Framework
         */
        const val TOKEN_TYPE_BEARER: String = "bearer"

        @VisibleForTesting
        const val KEY_REQUEST: String = "request"

        @VisibleForTesting
        const val KEY_ADDITIONAL_PARAMETERS: String = "additional_parameters"

        @VisibleForTesting
        const val KEY_EXPIRES_AT: String = "expires_at"

        // TODO: rename all KEY_* below to PARAM_* - they are standard OAuth2 parameters
        @VisibleForTesting
        const val KEY_STATE: String = "state"

        @VisibleForTesting
        const val KEY_TOKEN_TYPE: String = "token_type"

        @VisibleForTesting
        const val KEY_AUTHORIZATION_CODE: String = "code"

        @VisibleForTesting
        const val KEY_ACCESS_TOKEN: String = "access_token"

        @VisibleForTesting
        const val KEY_EXPIRES_IN: String = "expires_in"

        @VisibleForTesting
        const val KEY_ID_TOKEN: String = "id_token"

        @VisibleForTesting
        const val KEY_SCOPE: String = "scope"

        private val BUILT_IN_PARAMS: Set<String> = setOf<String>(
            KEY_TOKEN_TYPE,
            KEY_STATE,
            KEY_AUTHORIZATION_CODE,
            KEY_ACCESS_TOKEN,
            KEY_EXPIRES_IN,
            KEY_ID_TOKEN,
            KEY_SCOPE
        )

        /**
         * Reads an authorization response from a JSON string representation produced by
         * [.jsonSerialize].
         *
         * @throws JSONException if the provided JSON does not match the expected structure.
         */
        @JvmStatic
        @Throws(JSONException::class)
        fun jsonDeserialize(json: JSONObject): AuthorizationResponse {
            require(json.has(KEY_REQUEST)) { "authorization request not provided and not found in JSON" }

            return AuthorizationResponse(
                request = AuthorizationRequest.jsonDeserialize(json.getJSONObject(KEY_REQUEST)),
                state = json.getStringIfDefined(KEY_STATE),
                tokenType = json.getStringIfDefined(KEY_TOKEN_TYPE),
                authorizationCode = json.getStringIfDefined(KEY_AUTHORIZATION_CODE),
                accessToken = json.getStringIfDefined(KEY_ACCESS_TOKEN),
                accessTokenExpirationTime = json.getLongIfDefined(KEY_EXPIRES_AT),
                idToken = json.getStringIfDefined(KEY_ID_TOKEN),
                scope = json.getStringIfDefined(KEY_SCOPE),
                additionalParameters = json.getStringMap(KEY_ADDITIONAL_PARAMETERS)
            )
        }

        /**
         * Reads an authorization request from a JSON string representation produced by
         * [.jsonSerializeString]. This method is just a convenience wrapper for
         * [.jsonDeserialize], converting the JSON string to its JSON object form.
         *
         * @throws JSONException if the provided JSON does not match the expected structure.
         */
        @JvmStatic
        @Throws(JSONException::class)
        fun jsonDeserialize(jsonStr: String): AuthorizationResponse {
            return jsonDeserialize(JSONObject(jsonStr))
        }

        /**
         * Extracts an authorization response from an intent produced by [.toIntent]. This is
         * used to extract the response from the intent data passed to an activity registered as the
         * handler for [AuthorizationService.performAuthorizationRequest].
         */
        @JvmStatic
        fun fromIntent(dataIntent: Intent): AuthorizationResponse? {
            if (!containsAuthorizationResponse(dataIntent)) return null

            try {
                return jsonDeserialize(dataIntent.getStringExtra(EXTRA_RESPONSE)!!)
            } catch (ex: JSONException) {
                throw IllegalArgumentException("Intent contains malformed auth response", ex)
            }
        }

        @JvmStatic
        fun containsAuthorizationResponse(intent: Intent) = intent.hasExtra(EXTRA_RESPONSE)
    }
}
